[
    {
        "filename": "202512310002cinnamon4 documentation-4.1.0.md",
        "title": "Changes in Cinnamon 4.1.0",
        "subtitle": "How it's shaped, now that it's been decoupled from discord.py",
        "thumbnail": "https://i.imgur.com/5IQKzNi.png",
        "content": "# Changes in Cinnamon 4.1.0\n## How it's shaped, now that it's been decoupled from discord.py\n\nAfter watching discord become what it currently is, I've been itching to make my chatbot (not my OS) Cinnamon client-agnostic for probably the better part of a year, and have finally committed to it.. as of a couple weeks ago. I'm happy to say that: I've done it. And broken everything in the process, that I've since... _mostly_ fixed\n\n## How I've Broken Everything - 4.1 Changes\n\n### 1. cinLogging changes\n\nSince I broke everything and had to keep looking at my disgusting logging: new logging system uses the new `BoxParams` dataclass in `cinPalette.py`:\n\n```python\n@dataclass(slots=True, frozen=True)\nclass BoxParams:\n    box_color: str = highlightedColor\n    box_indentation: int = 1\n    indentation: int = 1\n    width: int = 40\n    text_color: str = defaultColor\n    alt_first_border: bool = False\n```\n\nThis allows for consistent theming across different logging contexts through predefined boxParams (read: themes) like `LARGE_WINDOW`, `ERROR_BOX`, and `LOAD_STATUS`. This is used for `cinLogging.printBoxBorderP(boxParams)` and `cinLogging.printInBoxP(text, boxParams)` to produce windows like this:\n\n### LOOK HOW NOT-TRASH THESE ERRORS ARE!\n\n![plugin loading with the new printInBox() system](https://i.imgur.com/5IQKzNi.png)\n![and message logging](https://i.imgur.com/cMxfe6I.png)\n\nwhere it used to be... this\n![old system plugin loading... very one color, and formatted like the wild mf west](https://i.imgur.com/9yunkTk.png)\n![old system for logging messages... mentioning channel context every single time... ew......](https://i.imgur.com/2AbYVCV.png)\n\n`printInBoxP()` makes an attempt to smartly wrap the text you give it to the character width of the boxParams you provide it. It does a pretty decent job, but doesn't handle emoji very well, causing misalignments \n\n### 2. Protocol-Based Abstraction (cinAPI pt 1)\n\nto \"replace\" `discord.py`-specific code, I'm using Python's `Protocol` classes to define interfaces without inheritance, in a way that's currently very `discord.py` shaped:\n\n```python\n# actual class in cinAPI.py\nclass APIMessage(Protocol): # definitely not a discord.py message object\n    content: str  \n    author: APIUser  \n    channel: APIChannel  \n    created_at: datetime  \n    attachments: List[Any]  \n    embeds: List[Any]  \n    guild: Optional[APIGuild]  \n    id: int  \n    client_name: str  \n  \n    async def reply(self, reply_text,mention_author):  \n        # gets message context, to send a message in the same channel  \n        ...\n```\n\n**Pros**:\n- No dependency on specific client libraries\n- Core and logging have never even heard of what a discord is! They just get tossed cinAPI shaped events from some `discord_api.py` thing, check if they match any of the handlers bound by the imported plugins, and the plugins shove more cinAPI-shaped things back into the thing-the-events-came-from hole.\n- Runtime type checking via `validate_handler()` shows me all the places I duck-typed myself into a skill issue hole with every last one of my plugins. \n- New client implementations shouldn't be too hard to write, when I choose to migrate from discord. Porting to a new client library is now just writing a new `<context>_api.py` in `./api_contexts/`\n**Cons**:\n - Every plugin was at some point broken\n - Structure is more OOPy, with protocols and inheritance and such\n - And that's AFTER doing all of the other work in this writeup\n\n### 3. CinAPIManager Singleton (cinAPI pt 2)\n`CinAPIManager` assumes a few roles previously hardcoded into core, as a single point of control for:\n- Client registration and retrieval\n- Event handler routing\n- Global state management\n\nThis decouples plugins from clients, and.. core from some previously hardcoded parts of core\n\n### 4. Signature Validation for Plugin Registry System\nPlugin Registry was 4.0, but to support cinAPI in 4.1, **Signature validation** has been added to ensure plugins are using objects that follow the new client-agnostic cinAPI protocols. This also makes errors log more explicitly.\n\n### misc changes:\n- loop tasks are now handled by asyncio directly, instead of as a discord.py task, which shouldn't need any changes to plugins' bind functions\n- betterEmbeds plugin - just replies to messages containing direct links from reddit and twitter & such, with embeddable versions of the same link. \n- reminder plugin now tracks the APIClient a message was received from, to.. ask the right client where to send the reminder message \n- cinTypes no longer exists\n- cinMessageUtil was basically just a proto-cinAPI.APIMessage, so that's gone, too\n- cinShared has been largely rolled into cinReminders and cinLogging, where it was most used, and is now also gone.\n\n---\n---\n# How Things Look Now That I've Broken Everything(tm):\n\n```\n┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐\n│  Platform API   │    │   API Context   │    │                 │\n│      layer      │────▶     Adapter     │────▶                 │\n│   (discord.py)  │    │ (discord_api.py)│    │                 │\n│ event dispatch  │    │                 │    │ cinAPI Protocol │ \n└─────────────────┘    └─────────────────┘    │  (APIMessage,   │\n                                              │  APIUser, etc.) │\n┌─────────────────┐                           │ event dispatch  │\n│  Future         │    ┌─────────────────┐    │                 │\n│  Platform       │────▶  Future         │    │                 │\n│  (not discord)  │    │  Adapter        │────▶                 │\n└─────────────────┘    └─────────────────┘    └────────────┬────┘\n                                                           │\n                                                           ▼\n┌───────────────────────────────────────────────────────────────┐\n│           Protocol-Based Bot Core (bot.py)               │    │\n├─────────────────────────────────────────────────────┐    │    │\n│  - Plugin Loading on initialization:                │    ▼    │\n│      for each plugin in ./plugins/ :                │         │\n│        import plugin and call bind_*() functions to │    │    │\n│        register handlers for commands, phrases, etc │    │    │\n│                                                     │    ▼    │\n│  - Event Handlers (registered with cinAPI):         │         │\n│      on_ready, on_message, on_reaction              │    │    │\n│                                                     │    │    │\n│  - Client loading                                   │    │    │\n│                                                     │    │    │\n│  - Main Loop:                                       │    ▼    │\n│      runs bound loop functions from plugins         │         │\n├─────────────────────────────────────────────────────┘    │    │\n│  When a cinAPI event arrives:                         ◀──┘    │\n│      if event matches a registered binding pattern:           │\n│              call plugin's handler                            │\n└───────────────────────────────────────────────────────────────┘\n                                    │\n                                    │ (calls)\n                                    ▼\n┌───────────────────────────────────────────────────────────────┐\n│                          Plugins                              │\n│                                                               │\n│                    Example plugin binding:                    │\n│    def bind_commands():                                       │\n│        return {\"mycommand\": my_command}                       │\n│                                                               │\n│        handler triggered on every message that starts         │\n│              with \"!>mycommand\", from any client:             |\n│                                                               │\n│    async def my_command(message: APIMessage):                 │\n│        await message.channel.send(\"Hello!\")                   │\n└───────────────────────────────────────────────────────────────┘\n```\n\n```python\ncinnamon4/\n├── bot.py # core - loads other modules, plugins, and clients\n├── cinAPI.py # API protocol all contexts must implement, + manager singleton\n├── cinIO.py # basic IO wrapper for configs and caches\n├── cinLogging.py # does stuff\n├── cinPalette.py # style / formatting consistency\n│\n├── api_contexts/\n│   ├── base.py # base mixin\n│   └── discord_api.py # discord api layer\n│\n├── plugins/\n│   ├── betterEmbeds/\n│   │   └── __init__.py # replaces direct links with embeddable ones\n│   ├── cinDice/\n│   │   └── __init__.py # rolls D&D dice\n│   ├── cinReminders/\n│   │   └── __init__.py # load-bearing reminder plugin that I use too much\n│   ├── cinSolve/\n│   │   └── __init__.py # just a calculator that uses eval() with a whitelist\n│   ├── help/\n│   │   └── __init__.py # help system is plugin, too!\n│   └── tatoclip_plugin/ # NOT broken at the time of writing actually, I FIXED it\n│       ├── __init__.py # tatoclip integration\n│       ├── file_operations.py\n│       ├── metadata_handler.py\n│       ├── notes/\n│       ├── project_validation.py\n│       └── time_utils.py\n│\n├── assets/\n├── cache/\n│   ├── tatoclip/\n│   │   ├── <guild_id>/\n│   │   │   └── targets_<whatever>.json files live here\n│   │   └── tatoclip_config.json\n│   ├── reminders.json\n│   └── userData.json # currently just time zones\n├── configs/\n│   ├── config.yaml\n│   └── token.yaml\n├── logs/\n│   └── <guild_name>/\n│       └── <channel_name>.html log files live here\n├── README.md\n├── documentation-4.1.0.md # you are here\n└── help.md\n```\n\n"
    },
    {
        "filename": "202510241259site deployment script.md",
        "title": "Shiny new Site Deployment Script",
        "subtitle": "woooo deploying this site doesn't suck so much anymore- ",
        "thumbnail": "https://i.imgur.com/R7ljDB7.png",
        "content": "# Shiny new Site Deployment Script\n\nI will NOT get into the details of how I was deploying these posts before (in this post at least?), but it's hosted on both github pages and neocities, with neocities pulling the post data from github pages to reduce the draw on neocities' servers as much as possible. When I push to the repository, the site updates.\n\n![screenshot of deploy.sh's source, with it running in a terminal window overlaid on top](https://i.imgur.com/R7ljDB7.png)\n\n### woooo deploying this site doesn't suck so much anymore- \n\nIt took like an hour of trying to remember how git worked, but now I don't have to think about that for another year, because publishing is just a double click away now. It's is not that major of a change, but I'm trying to make as much of this website as I can myself, so, little quality of life things like this are nice. I'm reducing my friction for writing little posts like these, somewhere that isn't twitteresc. It's nice-\n\n\nI'm just gonna hit save on this, click a the thing, and it totally won't error the moment I try to commit a real change.\n\n\n***\n<br>\nEDIT: Y'all I have hilarious news. My check for whether or not there were changes? Inverted. Detecting changes in the build script. Whoops.\n<br>\nEDIT 2: Code block for the deployment script, since why not:\n\n```bash\n#!/bin/bash\n\nCOMMIT_MSG=\"${1:-bump}\" # COMMIT_MSG = arg1 ? arg1 : \"bump\"\n\nRED='\\033[0;31m'\nGREEN='\\033[1;32m'\nCYAN='\\033[1;36m'\nGRAY='\\033[0;37m'\nC='\\033[0m'\n\necho\n\n# build\necho -e \"${CYAN}    ----    Starting build...    ----    \\n${C}\"\nif ! python3 build_js.py; then\n    echo -e \"${RED}\\n\\n    Build failed!\\n\\n${C}\"\n    exit 1\nfi\n\n# changes ? commit : no\necho\nif git diff-index --quiet HEAD --; then\n    echo -e \"${GRAY}    ----    No changes to commit.    ----    ${C}\"\nelse\n    echo -e \"${CYAN}    ----    Changes detected, committing...    ----    \\n${C}\"\n    git add . && \\\n    git commit -m \"$COMMIT_MSG\"\nfi\n\n# Push either way\necho -e \"\\n${CYAN}    ----    Pushing to GitHub...    ----    ${C}\\n\"\nif ! git push origin main; then\n    echo -e \"\\n\\n${RED}    ----    Failed to push to GitHub!    ----    ${C}\"\n    exit 1\nfi\n\necho -e \"${GREEN}\\n\\n    ----    Deployment completed successfully! Haven gice done    ----    \\n\\n${C}\"\n\n\nread -p \"[press any to close] \" -n1 -s\n```\n\nEDIT 3: Actually y'know what, have build_js.py too. These two scripts are how I'm deploying the site every time I make a minor edit like this:\n\n```python\nimport os\nimport re\nimport json\n\nPOSTS_DIR = './posts'\n\ndef parse_markdown(content):\n    # extract title (first level header `#`)\n    title_match = re.search(r'^# (.+)', content, re.MULTILINE)\n    title = title_match.group(1) if title_match else 'Untitled'\n\n    # extract subtitle (second level header `##`)\n    subtitle_match = re.search(r'^## (.+)', content, re.MULTILINE)\n    subtitle = subtitle_match.group(1) if subtitle_match else ''\n    \n    if subtitle == \"\":  # if contains no ##, try first ###\n        subtitle_match2 = re.search(r'^### (.+)', content, re.MULTILINE)\n        subtitle = subtitle_match2.group(1) if subtitle_match2 else ''\n\n    # extract thumbnail (first image URL `![](url)`)\n    thumbnail_match = re.search(r'!\\[.*?\\]\\((.*?)\\)', content)\n    thumbnail = thumbnail_match.group(1) if thumbnail_match else ''\n\n    return {\n        'title': title,\n        'subtitle': subtitle,\n        'thumbnail': thumbnail,\n        'content': content\n    }\n\ndef build_output_files(posts_dir):\n    posts_data = []\n\n    # foreach .md in dir\n    for filename in os.listdir(posts_dir): # can probably python list comprehension this one? but those aren't... readable.......\n        if filename.endswith('.md'):\n            with open(os.path.join(posts_dir, filename), 'r', encoding='utf-8') as f:\n                content = f.read()\n                post_data = parse_markdown(content)\n                posts_data.append({\n                    'filename': filename,\n                    'title': post_data['title'],\n                    'subtitle': post_data['subtitle'],\n                    'thumbnail': post_data['thumbnail'],\n                    'content': post_data['content']\n                })\n\n    # sort posts by most recent first (filename alphabetical, reversed)\n    posts_data.sort(key=lambda x: x['filename'], reverse=True)\n\n    # split into recent and whatever else for faster initial loading\n    recent_posts = posts_data[:2]\n    older_posts = posts_data[2:]\n\n    # generate JSON versions (for Neocities)\n    with open('recentPosts.json', 'w', encoding='utf-8') as f:\n        json.dump(recent_posts, f, indent=4, ensure_ascii=False)\n    \n    with open('olderPosts.json', 'w', encoding='utf-8') as f:\n        json.dump(older_posts, f, indent=4, ensure_ascii=False)\n\n    # generate JSONP versions (for GitHub Pages)\n    # todo: figure out how to get github pages to accept json-\n    with open('recentPosts.js', 'w', encoding='utf-8') as f:\n        f.write(f'handleRecentPosts({json.dumps(recent_posts, indent=4, ensure_ascii=False)});')\n    \n    with open('olderPosts.js', 'w', encoding='utf-8') as f:\n        f.write(f'handleOlderPosts({json.dumps(older_posts, indent=4, ensure_ascii=False)});')\n\n    print(\"Generated files successfully!\")\n    print(\"- JSON (for Neocities): recentPosts.json, olderPosts.json\")\n    print(\"- JSONP (for GitHub): recentPosts.js, olderPosts.js\")\n\nif __name__ == '__main__':\n    build_output_files(POSTS_DIR)\n```\n"
    }
]