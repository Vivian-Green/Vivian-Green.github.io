[
    {
        "filename": "202510231432cinnamon4 post time finally.md",
        "title": "So I Rewrote My Discord Bot For the Fourth Time",
        "subtitle": "W H Y",
        "thumbnail": "Screenshot from 2025-10-23 14-30-53.png",
        "content": "***\n\n# So I Rewrote My Discord Bot For the Fourth Time\n\nMy friends and unwitting friends, I bring a rare tale of success in rewriting a codebase-\n\n![Screenshot of me in discord deciding to rewrite this thing again again](Screenshot from 2025-10-23 14-30-53.png)\n\nCinnamon, my discord bot, is both a very poorly named project [(considering )my recent choice of OS)](https://linuxmint.com/download.php) and easily my oldest still-maintained project. It started around 2017-2018 as a random side project that was used for shitposting and discord D&D, which, over six years, accidentally snowballed in scope into having a few useful features. The most used being reminders, a calculator function, and dice rolling, but it grew and shrunk in scope over the years, as I added features, and decided they were cringe. Maybe I can dig up the old help page for the bot... oh no I can totally just host that here too, can't I-\n\n[TODO: POST, THEN INLINE LINK THE OLD HELP PAGE] \n\nIn any case, the original cinnamon was just bot.py, which lasted a year or two, until I tried to use it, and found that discord.py had been deprecated. My response to this was to just rewrite the entire thing in node.js around 2019. We do not talk about cinnamon2. Cinnamon2 was written in javascript. \n\nThe moment I found out that discord.py had support again, I took the old python code and migrated things over, and extended it to have feature parity with the node.js version, before throwing that directly into the trash. This was then split into some of the core modules I still use, as well as other modules that later became plugins, in the rewrite this post is actually about!\n\n## W H Y\n\nSo I was trying to add a *new* bit of functionality to the bot, to help with making my silly little unofficial BLG compilations. I wanted it to be able to handle building my project files for me. I found myself staring at a codebase that'd been extended for 6+ years, without any major restructuring since being split into modules post-javascript.\n\nThe problem wasn't that the code was in modules - it was how those modules were organized. I had some separation of concerns, but all of the interfacing with the modules was hardcoded into bot.py with specific command handlers and function calls. Want to add a new feature? Gotta trudge through the main bot file and figure out where you actually need to look, in the still 1800-line-not-monolith.\n\nLooking at the old `bot.py`, you can see the problem:\n\n```python\n# OLD: Hardcoded module imports and function calls\nimport cinReminders\nimport cinSolve\nimport cinYoinkytModule\n# ... 20 more lines of imports ...\n\n# OLD: Manual command routing in a giant match/case statement\nmatch command:\n    case \"remindme\" | \"reminder\":\n        await cinReminders.newReminder(wordsCaseSensitive[1:], message)\n    case \"solve\":\n        await cinSolve.solve(message, messageContent)\n    case \"clip\":\n        await cinYoinkytModule.clip(words, message)\n    # ... 15 more cases ...\n```\n\nSo I gutted it. *Again.* The main script is 281 lines now. It loads everything it needs to. \n\n## Fixing that Godawful Mess with Minimal Tape\n\nMost of my modules already *were* trying to be plugins, they just lacked any system for bindings, being used as hardcoded dependencies rather than extensions, and as such, were still a bit too interconnected with main.\n\nThis really wasn't that much tape:\n\n```python\ndef load_plugins():\n    printHighlighted(f\"{fiveLines}Loading plugins...\")\n    plugins_dir = Path(\"./plugins\")\n\n    # Iterate through all directories in the plugins folder\n    for plugin_dir in plugins_dir.iterdir():\n        printLabelWithInfo(\"  plugin\", plugin_dir)\n        ... (guard clauses)\n\n        # Create the module spec and import it\n        module_name = f\"plugins.{plugin_dir.name}\"\n        spec = importlib.util.spec_from_file_location(module_name, init_file)\n\n        module = importlib.util.module_from_spec(spec)\n        spec.loader.exec_module(module)  # type: ignore\n\n        # Call the bind functions if they exist\n        if hasattr(module, \"bind_commands\"):\n            cmd_dict = module.bind_commands()\n            if isinstance(cmd_dict, dict):\n                commands.update(cmd_dict)\n                printLabelWithInfo(\"    commands\", cmd_dict)\n            else:\n                printErr(f\"bind_commands() in plugin {plugin_dir} returned invalid data? {cmd_dict}\")\n        ... (like 4 other bind functions)\n```\n\nThat's all it took to get those [Dependencies Inverted(tm)](https://en.wikipedia.org/wiki/Dependency_inversion_principle ) and [Concerns Separated(tm)](https://en.wikipedia.org/wiki/Separation_of_concerns) through the Registry Pattern(tm). My coupling! It's [loose!](https://en.wikipedia.org/wiki/Loose_coupling) The interfaces are informal/implicit (bind_commands has its input and output types, but... I'm not enforcing much-) because... well to be honest, I'm the one writing these plugins, I can just use my binding functions as they're defined ðŸ‘‰ðŸ‘‰\n\nIn english: That loader is the function I needed to detangle my high-level feature code from by low-level implementation code. It should ask more questions than it does, but that's probably fine.\n\nBefore I had functionality scattered across modules that were all in the root folder, manually imported and bound into hardcoded command handlers. Now each plugin is its own self-contained unit, defining its own commands, help, message handlers, reaction handlers, and background tasks, and registering all of that on load. The main script discovers and loads plugins instead of having to know about every possible command and feature. Nobody cares what the other side of the phone is doing. \n\nThis made development so much nicer. It was starting to become a *task* to extend cinnamon, even with the modules, but now with ~plugins~ it's so much easier. It feels more like modding a game than extending a codebase - because there's enough of a framework to focus on the fun parts <3\n\n```python\nimport cinShared\n\nasync def test_command(message):\n    await message.channel.send(\"yo\")\n\ndef bind_commands():\n     return {\n         \"test\": test_command\n     }\n```\n\nLook at that. Like tell me that doesn't look straight out of a BepinEx tutorial... but in python... ok it's a stretch, but that's an entire discord bot plugin! You could take the core of my discord bot, and its plugin documentation, have no idea how the code works, write that, and have a functional discord bot that does the thing you asked it to. There's a decent amount under the hood to make it work, and that plugin doesn't exactly *do* much, but, but that into a folder in the plugins folder, call it `__init__.py`, and she'll run.\n\n## And it was actually worth it???\n\nIt took like a week, and I could still reuse 90% of what I started with, so the time sink wasn't nearly as bad as I thought it would be; and now when I get the urge to add something new at 2 AM, I don't have to worry about accidentally breaking the reminder system that I actually depend on. If the new plugin fails to load, it's just that plugin. And if that command errors, it's just that command- It fails so gracefully and informatively ;-;\n\nAll of the tape on the loader side has been written. If, for some obscene reason I need to write more tape on the loader side (eg., a new binding function), I don't have to change any of the tape on the other side. Besides that, all future tape will be on the plugin side. I don't have to look between files to check if I'm calling things right. That's **so** nice. I could work on this for another 6 years.\n\nNow to abstract away the discord api dependency...\n\n\n\n\n\n\n\n"
    },
    {
        "filename": "202508161435website overhaul again.md",
        "title": "Updating How These Posts are Stored, Maybe This Works",
        "subtitle": "",
        "thumbnail": "https://i.imgur.com/VQj37QV.png",
        "content": "# Updating How These Posts are Stored, Maybe This Works\n\nSo I'm writing this update to see if this site is properly importing data from github. If so, only 16KB of this page was sent through neocities, and I can avoid potential strain on their servers. Will I ever get enough traffic to strain their servers otherwise? Almost definitely not, but eh.\n\nOk **SO-** goddamn that was a pain. I'm trying (and now succeeding) to load post data from github, and core site data on neocities. I was already building these posts to *javascript* files, and then decided to convert to json to try and do things \"properly.\" This resulted in MIME type and CORS shenanigans, for a while. Apparently, neocities' CSP didn't want me to offload work from them, and wouldn't let me import json. Ended up settling on JSONP... which is... javascript. I was building to javascript instead of json originally. I'm just making very slightly differently flavored javascript, wrapping the data in a function instead of a variable, and this works. Sure, why not. It's javascript, idk why I expected it to stop being haunted.\n\nLo, another piece of tape has been placed on the interconnected web of tape; but nobody wept, for they already knew.\n\n![](https://i.imgur.com/VQj37QV.png)\n"
    }
]