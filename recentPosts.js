handleRecentPosts([
    {
        "filename": "202510241259site deployment script.md",
        "title": "Shiny new Site Deployment Script",
        "subtitle": "woooo deploying this site doesn't suck so much anymore- ",
        "thumbnail": "https://i.imgur.com/R7ljDB7.png",
        "content": "# Shiny new Site Deployment Script\n\nI will NOT get into the details of how I was deploying these posts before (in this post at least?), but it's hosted on both github pages and neocities, with neocities pulling the post data from github pages to reduce the draw on neocities' servers as much as possible. When I push to the repository, the site updates.\n\n![screenshot of deploy.sh's source, with it running in a terminal window overlaid on top](https://i.imgur.com/R7ljDB7.png)\n\n### woooo deploying this site doesn't suck so much anymore- \n\nIt took like an hour of trying to remember how git worked, but now I don't have to think about that for another year, because publishing is just a double click away now. It's is not that major of a change, but I'm trying to make as much of this website as I can myself, so, little quality of life things like this are nice. I'm reducing my friction for writing little posts like these, somewhere that isn't twitteresc. It's nice-\n\n\nI'm just gonna hit save on this, click a the thing, and it totally won't error the moment I try to commit a real change.\n\n\n***\n<br>\nEDIT: Y'all I have hilarious news. My check for whether or not there were changes? Inverted. Detecting changes in the build script. Whoops.\n<br>\nEDIT 2: Code block for the deployment script, since why not:\n```bash\n#!/bin/bash\n\nCOMMIT_MSG=\"${1:-bump}\" # COMMIT_MSG = arg1 ? arg1 : \"bump\"\n\nRED='\\033[0;31m'\nGREEN='\\033[1;32m'\nCYAN='\\033[1;36m'\nGRAY='\\033[0;37m'\nC='\\033[0m'\n\necho\n\n# build\necho -e \"${CYAN}    ----    Starting build...    ----    \\n${C}\"\nif ! python3 build_js.py; then\n    echo -e \"${RED}\\n\\n    Build failed!\\n\\n${C}\"\n    exit 1\nfi\n\n# changes ? commit : no\necho\nif git diff-index --quiet HEAD --; then\n    echo -e \"${GRAY}    ----    No changes to commit.    ----    ${C}\"\nelse\n    echo -e \"${CYAN}    ----    Changes detected, committing...    ----    \\n${C}\"\n    git add . && \\\n    git commit -m \"$COMMIT_MSG\"\nfi\n\n# Push either way\necho -e \"\\n${CYAN}    ----    Pushing to GitHub...    ----    ${C}\\n\"\nif ! git push origin main; then\n    echo -e \"\\n\\n${RED}    ----    Failed to push to GitHub!    ----    ${C}\"\n    exit 1\nfi\n\necho -e \"${GREEN}\\n\\n    ----    Deployment completed successfully! Haven gice done    ----    \\n\\n${C}\"\n\n\nread -p \"[press any to close] \" -n1 -s\n```\n<br>\nEDIT 3: Actually y'know what, have build_js.py too:\n\n```python\nimport os\nimport re\nimport json\n\nPOSTS_DIR = './posts'\n\ndef parse_markdown(content):\n    # extract title (first level header `#`)\n    title_match = re.search(r'^# (.+)', content, re.MULTILINE)\n    title = title_match.group(1) if title_match else 'Untitled'\n\n    # extract subtitle (second level header `##`)\n    subtitle_match = re.search(r'^## (.+)', content, re.MULTILINE)\n    subtitle = subtitle_match.group(1) if subtitle_match else ''\n    \n    if subtitle == \"\":  # if contains no ##, try first ###\n        subtitle_match2 = re.search(r'^### (.+)', content, re.MULTILINE)\n        subtitle = subtitle_match2.group(1) if subtitle_match2 else ''\n\n    # extract thumbnail (first image URL `![](url)`)\n    thumbnail_match = re.search(r'!\\[.*?\\]\\((.*?)\\)', content)\n    thumbnail = thumbnail_match.group(1) if thumbnail_match else ''\n\n    return {\n        'title': title,\n        'subtitle': subtitle,\n        'thumbnail': thumbnail,\n        'content': content\n    }\n\ndef build_output_files(posts_dir):\n    posts_data = []\n\n    # foreach .md in dir\n    for filename in os.listdir(posts_dir): # can probably python list comprehension this one? but those aren't... readable.......\n        if filename.endswith('.md'):\n            with open(os.path.join(posts_dir, filename), 'r', encoding='utf-8') as f:\n                content = f.read()\n                post_data = parse_markdown(content)\n                posts_data.append({\n                    'filename': filename,\n                    'title': post_data['title'],\n                    'subtitle': post_data['subtitle'],\n                    'thumbnail': post_data['thumbnail'],\n                    'content': post_data['content']\n                })\n\n    # sort posts by most recent first (filename alphabetical, reversed)\n    posts_data.sort(key=lambda x: x['filename'], reverse=True)\n\n    # split into recent and whatever else for faster initial loading\n    recent_posts = posts_data[:2]\n    older_posts = posts_data[2:]\n\n    # generate JSON versions (for Neocities)\n    with open('recentPosts.json', 'w', encoding='utf-8') as f:\n        json.dump(recent_posts, f, indent=4, ensure_ascii=False)\n    \n    with open('olderPosts.json', 'w', encoding='utf-8') as f:\n        json.dump(older_posts, f, indent=4, ensure_ascii=False)\n\n    # generate JSONP versions (for GitHub Pages)\n    # todo: figure out how to get github pages to accept json-\n    with open('recentPosts.js', 'w', encoding='utf-8') as f:\n        f.write(f'handleRecentPosts({json.dumps(recent_posts, indent=4, ensure_ascii=False)});')\n    \n    with open('olderPosts.js', 'w', encoding='utf-8') as f:\n        f.write(f'handleOlderPosts({json.dumps(older_posts, indent=4, ensure_ascii=False)});')\n\n    print(\"Generated files successfully!\")\n    print(\"- JSON (for Neocities): recentPosts.json, olderPosts.json\")\n    print(\"- JSONP (for GitHub): recentPosts.js, olderPosts.js\")\n\nif __name__ == '__main__':\n    build_output_files(POSTS_DIR)\n```\n"
    },
    {
        "filename": "202510231432cinnamon4 post time finally.md",
        "title": "So I Rewrote My Discord Bot For the Fourth Time",
        "subtitle": "W H Y",
        "thumbnail": "https://i.imgur.com/8uXF24C.png",
        "content": "# So I Rewrote My Discord Bot For the Fourth Time\n\nMy friends and unwitting friends, I bring a rare tale of success in rewriting a codebase- (from like 5 months ago)\n\n![thumbnail](https://i.imgur.com/8uXF24C.png)\n![Screenshot of me in discord deciding to rewrite this thing again again](https://i.imgur.com/PooABUM.png)\n\n\n[Cinnamon4](https://github.com/Vivian-Green/cinnamon4), my discord bot, is both a very poorly named project [(considering my recent choice of OS)](https://linuxmint.com/download.php) and easily my oldest still-maintained project. It started in 2017 as a random side project that was used for shitposting and discord D&D, which, over six years, accidentally snowballed in scope into having a few useful features. The most used being reminders, a calculator function, and dice rolling, but it grew and shrunk in scope over the years, as I added features, and decided they were cringe. Maybe I can dig up the old help page for the bot... oh no I can totally [just host that here too](https://vivianswebsite.neocities.org/cinnamon_help_2023), can't I-\n\nIn any case, the original cinnamon was just bot.py, which lasted a year or two, until I tried to use it, and found that discord.py had been deprecated. My response to this was to just rewrite the entire thing in node.js around 2019. We do not talk about Cinnamon2. [Cinnamon2](https://github.com/Vivian-Green/cinnamon-js) was written in javascript. \n\nThe moment I found out that discord.py had support again, I took the old python code and migrated things over, then extended it to have feature parity with the node.js version, before throwing the javascript directly into the trash. This was then split into some of the core modules I still use, as well as other modules that later became plugins in the rewrite this post is actually about! [Nonchalauntly shoehorned Cinnamon3 link](https://github.com/Vivian-Green/cinnamon-py)\n\n## W H Y\n\nSo I was trying to add a *new* bit of functionality to the bot, to help with making my silly little unofficial BLG compilations. I wanted it to be able to handle building my project files for me. I found myself staring at a codebase that'd been extended for 6+ years, without any major restructuring since being split into modules post-javascript.\n\nThe problem wasn't that the code was in modules- it was how those modules were organized. I had some separation of concerns, but all of the interfacing with the modules was hardcoded into bot.py with specific command handlers and function calls. Want to add a new feature? Gotta trudge through the main bot file and figure out where you actually need to look, in the still 1800-line-not-monolith.\n\nLooking at the old `bot.py`, you can see the problem:\n\n```python\nimport cinReminders\nimport cinSolve\nimport cinYoinkytModule\n# ... 20 more lines of hardcoded module imports ...\n\nmatch command:\n    case \"remindme\" | \"reminder\":\n        await cinReminders.newReminder(wordsCaseSensitive[1:], message)\n    case \"solve\":\n        await cinSolve.solve(message, messageContent)\n    case \"clip\":\n        await cinYoinkytModule.clip(words, message) # <- weird, inconsistent naming?\n    # ... way too many hardcoded cases  ...\n```\n\nSo I gutted it. *Again.* The main script is 281 lines now. It loads everything it needs to. \n\n## Fixing that Godawful Mess with Minimal Tape\n\nMost of my modules already *were* trying to be plugins, they just lacked any system for bindings, being used as hardcoded dependencies rather than extensions, and as such, were still a bit too interconnected with main.\n\nThis really wasn't that much tape:\n\n```python\ndef load_plugins():\n    printHighlighted(f\"{fiveLines}Loading plugins...\")\n    plugins_dir = Path(\"./plugins\")\n\n    # Iterate through all directories in the plugins folder\n    for plugin_dir in plugins_dir.iterdir():\n        printLabelWithInfo(\"  plugin\", plugin_dir)\n        # ... (guard clauses) ...\n\n        # Create the module spec and import it\n        module_name = f\"plugins.{plugin_dir.name}\"\n        spec = importlib.util.spec_from_file_location(module_name, init_file)\n\n        module = importlib.util.module_from_spec(spec)\n        spec.loader.exec_module(module)  # type: ignore\n\n        # Call the bind functions if they exist\n        if hasattr(module, \"bind_commands\"):\n            cmd_dict = module.bind_commands()\n            if isinstance(cmd_dict, dict):\n                commands.update(cmd_dict)\n                printLabelWithInfo(\"    commands\", cmd_dict)\n            else:\n                printErr(f\"bind_commands() in plugin {plugin_dir} returned invalid data? {cmd_dict}\")\n        # ... (like 4 other bind functions) ...\n```\n\nThat's all it took to get those [Dependencies Inverted(tm)](https://en.wikipedia.org/wiki/Dependency_inversion_principle) and [Concerns Separated(tm)](https://en.wikipedia.org/wiki/Separation_of_concerns) through the Registry Pattern(tm). My coupling! It's [loose!](https://en.wikipedia.org/wiki/Loose_coupling) The interfaces are informal/implicit (bind_commands has its input and output types, but... I'm not enforcing much-) because... well to be honest, I'm the one writing these plugins, I can just use my binding functions as they're defined ðŸ‘‰ðŸ‘‰\n\nIn english: That loader is the function I needed to detangle my high-level feature code from my low-level implementation code. It should ask more questions than it does, but that's probably fine.\n\nBefore I had functionality scattered across modules that were all in the root folder, manually imported and bound into hardcoded command handlers. Now each plugin is its own self-contained unit, defining and registering its own commands, help messages, message and reaction handlers, and background tasks. The script discovers and loads plugins, instead of having to already know about every possible command and feature; nobody cares what the other side of the phone is doing. \n\nThis made development so much smoother. It was starting to become a *task* to extend cinnamon, even with the modules, but now with ~plugins~ it's so much easier. It feels more like modding a game than extending a codebase- because there's enough of a framework to focus on the fun parts <3\n\n```python\nimport cinShared\n\nasync def test_command(message):\n    await message.channel.send(\"yo\")\n\ndef bind_commands():\n     return {\n         \"test\": test_command\n     }\n```\n\nLook at that- tell me that doesn't look straight out of a BepinEx tutorial... but in python... ok it's a stretch, but that's an entire discord bot plugin! You could take the core of my discord bot and its plugin documentation, have no idea how the code works, write the 6 lines above, and have a functional discord bot. There's a decent amount under the hood to make it work, and that plugin doesn't exactly *do* much, but, put that into a folder in the plugins folder, call it `__init__.py`, and she'll run.\n\n## And it was actually worth it???\n\nIt took like a week, and I could still reuse 90% of what I started with, so the time sink wasn't nearly as bad as I thought it would be. Now when I get the urge to add something new at 2 AM, I don't have to worry about accidentally breaking the reminder system that I actually depend on. If the new plugin fails to load, it's just that plugin. If that command errors, it's just that command- it fails so gracefully and informatively ;-;\n\nAll of the tape on the loader side has been written. If, for some obscene reason, I need to write more tape on the loader side (eg., a new binding function), I don't have to change any of the tape on the plugin side. Besides that, all future tape will be on the plugin side. I don't have to look between files to check if I'm calling things right. That's **so** nice. I could work on this for another 6 years.\n\nNow to abstract away the discord api dependency...\n"
    }
]);