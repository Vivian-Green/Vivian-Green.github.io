handleRecentPosts([
    {
        "filename": "202512310002cinnamon4 documentation-4.1.0.md",
        "title": "Changes in Cinnamon 4.1.0",
        "subtitle": "How it's shaped, now that it's been decoupled from discord.py",
        "thumbnail": "https://i.imgur.com/5IQKzNi.png",
        "content": "# Changes in Cinnamon 4.1.0\n## How it's shaped, now that it's been decoupled from discord.py\n\nAfter watching discord become what it currently is, I've been itching to make my chatbot (not my OS) Cinnamon client-agnostic for probably the better part of a year, and have finally committed to it.. as of a couple weeks ago. I'm happy to say that: I've done it. And broken everything in the process, that I've since... _mostly_ fixed\n\n## How I've Broken Everything - 4.1 Changes\n\n### 1. cinLogging changes\n\nSince I broke everything and had to keep looking at my disgusting logging: new logging system uses the new `BoxParams` dataclass in `cinPalette.py`:\n\n```python\n@dataclass(slots=True, frozen=True)\nclass BoxParams:\n    box_color: str = highlightedColor\n    box_indentation: int = 1\n    indentation: int = 1\n    width: int = 40\n    text_color: str = defaultColor\n    alt_first_border: bool = False\n```\n\nThis allows for consistent theming across different logging contexts through predefined boxParams (read: themes) like `LARGE_WINDOW`, `ERROR_BOX`, and `LOAD_STATUS`. This is used for `cinLogging.printBoxBorderP(boxParams)` and `cinLogging.printInBoxP(text, boxParams)` to produce windows like this:\n\n### LOOK HOW NOT-TRASH THESE ERRORS ARE!\n\n![plugin loading with the new printInBox() system](https://i.imgur.com/5IQKzNi.png)\n![and message logging](https://i.imgur.com/cMxfe6I.png)\n\nwhere it used to be... this\n![old system plugin loading... very one color, and formatted like the wild mf west](https://i.imgur.com/9yunkTk.png)\n![old system for logging messages... mentioning channel context every single time... ew......](https://i.imgur.com/2AbYVCV.png)\n\n`printInBoxP()` makes an attempt to smartly wrap the text you give it to the character width of the boxParams you provide it. It does a pretty decent job, but doesn't handle emoji very well, causing misalignments \n\n### 2. Protocol-Based Abstraction (cinAPI pt 1)\n\nto \"replace\" `discord.py`-specific code, I'm using Python's `Protocol` classes to define interfaces without inheritance, in a way that's currently very `discord.py` shaped:\n\n```python\n# actual class in cinAPI.py\nclass APIMessage(Protocol): # definitely not a discord.py message object\n    content: str  \n    author: APIUser  \n    channel: APIChannel  \n    created_at: datetime  \n    attachments: List[Any]  \n    embeds: List[Any]  \n    guild: Optional[APIGuild]  \n    id: int  \n    client_name: str  \n  \n    async def reply(self, reply_text,mention_author):  \n        # gets message context, to send a message in the same channel  \n        ...\n```\n\n**Pros**:\n- No dependency on specific client libraries\n- Core and logging have never even heard of what a discord is! They just get tossed cinAPI shaped events from some `discord_api.py` thing, check if they match any of the handlers bound by the imported plugins, and the plugins shove more cinAPI-shaped things back into the thing-the-events-came-from hole.\n- Runtime type checking via `validate_handler()` shows me all the places I duck-typed myself into a skill issue hole with every last one of my plugins. \n- New client implementations shouldn't be too hard to write, when I choose to migrate from discord. Porting to a new client library is now just writing a new `<context>_api.py` in `./api_contexts/`\n**Cons**:\n - Every plugin was at some point broken\n - Structure is more OOPy, with protocols and inheritance and such\n - And that's AFTER doing all of the other work in this writeup\n\n### 3. CinAPIManager Singleton (cinAPI pt 2)\n`CinAPIManager` assumes a few roles previously hardcoded into core, as a single point of control for:\n- Client registration and retrieval\n- Event handler routing\n- Global state management\n\nThis decouples plugins from clients, and.. core from some previously hardcoded parts of core\n\n### 4. Signature Validation for Plugin Registry System\nPlugin Registry was 4.0, but to support cinAPI in 4.1, **Signature validation** has been added to ensure plugins are using objects that follow the new client-agnostic cinAPI protocols. This also makes errors log more explicitly.\n\n### misc changes:\n- loop tasks are now handled by asyncio directly, instead of as a discord.py task, which shouldn't need any changes to plugins' bind functions\n- betterEmbeds plugin - just replies to messages containing direct links from reddit and twitter & such, with embeddable versions of the same link. \n- reminder plugin now tracks the APIClient a message was received from, to.. ask the right client where to send the reminder message \n- cinTypes no longer exists\n- cinMessageUtil was basically just a proto-cinAPI.APIMessage, so that's gone, too\n- cinShared has been largely rolled into cinReminders and cinLogging, where it was most used, and is now also gone.\n\n---\n---\n# How Things Work Now That I've Broken Everything(tm):\n\n```\n┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐\n│  Platform API   │    │   API Context   │    │                 │\n│      layer      │────▶     Adapter     │────▶                 │\n│   (discord.py)  │    │ (discord_api.py)│    │                 │\n│ event dispatch  │    │                 │    │ cinAPI Protocol │ \n└─────────────────┘    └─────────────────┘    │  (APIMessage,   │\n                                              │  APIUser, etc.) │\n┌─────────────────┐                           │ event dispatch  │\n│  Future         │    ┌─────────────────┐    │                 │\n│  Platform       │────▶  Future         │    │                 │\n│  (not discord)  │    │  Adapter        │────▶                 │\n└─────────────────┘    └─────────────────┘    └────────────┬────┘\n                                                           │\n                                                           ▼\n┌───────────────────────────────────────────────────────────────┐\n│           Protocol-Based Bot Core (bot.py)               │    │\n├─────────────────────────────────────────────────────┐    │    │\n│  - Plugin Loading on initialization:                │    ▼    │\n│      for each plugin in ./plugins/ :                │         │\n│        import plugin and call bind_*() functions to │    │    │\n│        register handlers for commands, phrases, etc │    │    │\n│                                                     │    ▼    │\n│  - Event Handlers (registered with cinAPI):         │         │\n│      on_ready, on_message, on_reaction              │    │    │\n│                                                     │    │    │\n│  - Client loading                                   │    │    │\n│                                                     │    │    │\n│  - Main Loop:                                       │    ▼    │\n│      runs bound loop functions from plugins         │         │\n├─────────────────────────────────────────────────────┘    │    │\n│  When a cinAPI event arrives:                         ◀──┘    │\n│      if event matches a registered binding pattern:           │\n│              call plugin's handler                            │\n└───────────────────────────────────────────────────────────────┘\n                                    │\n                                    │ (calls)\n                                    ▼\n┌───────────────────────────────────────────────────────────────┐\n│                          Plugins                              │\n│                                                               │\n│                    Example plugin binding:                    │\n│    def bind_commands():                                       │\n│        return {\"mycommand\": my_command}                       │\n│                                                               │\n│        handler triggered on every message that starts         │\n│              with \"!>mycommand\", from any client:             |\n│                                                               │\n│    async def my_command(message: APIMessage):                 │\n│        await message.channel.send(\"Hello!\")                   │\n└───────────────────────────────────────────────────────────────┘\n```\n\n```python\ncinnamon4/\n├── bot.py # core - loads other modules, plugins, and clients\n├── cinAPI.py # API protocol all contexts must implement, + manager singleton\n├── cinIO.py # basic IO wrapper for configs and caches\n├── cinLogging.py # does stuff\n├── cinPalette.py # style / formatting consistency\n│\n├── api_contexts/\n│   ├── base.py # base mixin\n│   └── discord_api.py # discord api layer\n│\n├── plugins/\n│   ├── betterEmbeds/\n│   │   └── __init__.py # replaces direct links with embeddable ones\n│   ├── cinDice/\n│   │   └── __init__.py # rolls D&D dice\n│   ├── cinReminders/\n│   │   └── __init__.py # load-bearing reminder plugin that I use too much\n│   ├── cinSolve/\n│   │   └── __init__.py # just a calculator that uses eval() with a whitelist\n│   ├── help/\n│   │   └── __init__.py # help system is plugin, too!\n│   └── tatoclip_plugin/ # NOT broken at the time of writing actually, I FIXED it\n│       ├── __init__.py # tatoclip integration\n│       ├── file_operations.py\n│       ├── metadata_handler.py\n│       ├── notes/\n│       ├── project_validation.py\n│       └── time_utils.py\n│\n├── assets/\n├── cache/\n│   ├── tatoclip/\n│   │   ├── <guild_id>/\n│   │   │   └── targets_<whatever>.json files live here\n│   │   └── tatoclip_config.json\n│   ├── reminders.json\n│   └── userData.json # currently just time zones\n├── configs/\n│   ├── config.yaml\n│   └── token.yaml\n├── logs/\n│   └── <guild_name>/\n│       └── <channel_name>.html log files live here\n├── README.md\n├── documentation-4.1.0.md # you are here\n└── help.md\n```\n\n---\n---\n# Documentation on the important core files\nFeel free to not look at any of this. It's for future vivian, lol. THIS IS AS OF 4.1.0 AND IS LIKELY ALREADY OUTDATED\n\n---\n---\n# bot.py:\n\nThe bot's core. Loads plugins and clients, and does its best to tape them together\n\n## initialization:\n- import core modules\n- load config.yaml and token.yaml via cinIO\n- plugin and handler discovery: for each \\_\\_init\\_\\_.py plugin in plugins:\n\t- check for binding functions to register commands, phrases, reactions, loop, and help handlers to their respective dispatchers\n- client discovery: for each hardcoded client api layer imported in hardCodedClientImport() in bot.py:\n\t- register client via cinAPI.register_client(), called from make_client(), from the api context module for the given client.\n\t- start client\n- loop initialization: \n\t- all loop functions found in plugins are bound to the same loop, ran every loopDelay (from config.yaml) seconds, in a task queued alongside client loads. The first loop is always loopDelay after initialization, whether clients are loaded or not.\n\n---\n## Plugins:\nEach plugin is a directory in `plugins/` containing an `__init__.py` file with specific binding functions:\n\n```python\ndef bind_commands() -> Dict[str, Callable[[cinAPI.APIMessage], Awaitable[None]]]:\n    return {\n        \"command_name\": command_handler_function\n    }\n\ndef bind_phrases() -> Dict[str, Callable[[cinAPI.APIMessage], Awaitable[None]]]:\n    return {\n        \"trigger_phrase\": phrase_handler_function\n    }\n\ndef bind_reactions() -> Dict[str, Callable[[cinAPI.APIReaction, cinAPI.APIUser], Awaitable[None]]]:\n    return {\n        \"message_phrase\": reaction_handler_function\n    }\n\ndef bind_loop() -> Callable[[], Awaitable[None]]:\n    return loop_function\n\ndef bind_help() -> Dict[str, str]:\n    return {\n        \"command_name\": \"Help text for command\"\n    }\n```\n\n### Plugin initialization\nDuring initialization, `bot.py`:\n- Iterates through all directories in `plugins/`, looking for `__init__.py` in each directory\n- Dynamically imports the `__init__.py` module\n- Checks for and calls binding functions to register handlers, validating handler signatures using runtime type checking\n- BEFORE CLIENT INITIALIZATION\n\n### Handler Types\n- **Commands**: Triggered by prefix (`!>`) followed by command name\n- **Phrase Handlers**: Triggered when message contains specific phrases\n- **Reaction Handlers**: Triggered on reactions to bot messages containing phrases\n- **Loop Functions**: Called periodically on the main loop every `<loopDelay>` seconds\n- **Help Entries**: Documentation for commands\n\n---\n---\n# cinAPI.py\n\nAllows Cinnamon to be client-agnostic instead of only supporting Discord. Uses Python's `Protocol` classes so everything talks to abstract shapes instead of specific libraries. \n\n```python\n# instead of discord.py objects, plugins only see these:\nclass APIMessage(Protocol):\n    content: str          # message text\n    author: APIUser       # who sent it\n    channel: APIChannel   # where it was sent\n    async def reply(self, text): ...  # how to respond\n\n# plugins don't care who sent an APIMessage, except to know that \"who\" is the square hole to shove more cinAPI-shaped objects into, in any response.\n```\n\n### How it works:\nThere's a `CinAPIManager` singleton and registry functions. Core fires the relevant registry functions on loading plugin bindings, and on loading clients. CinAPIManager is the tape that core references to handle routing client events to their relevant plugin handlers. \n\n- Client (Discord/etc.) events are wrapped in `cinAPI` protocol\n- `CinAPIManager` routes to registered plugin handlers\n- Plugin(s) respond using abstract methods, which route back to original client\n- Nobody has to hear about discord, except for `discord_api.py`, to which I owe great pity\n\n---\n---\n# cinIO.py\n\nWrapper that manages configs and cache files. Supports yaml OR json for configs, but ONLY json for caches. It does what I need it to do, which includes storing help entries, now\n\n```python\nconfig = loadConfig(\"config.yaml\")  # Load configs\ntoken = loadConfig(\"token.yaml\")[\"token\"]  # Get token\nuser_data = loadCache(\"userData.json\")  # Load cache\noverwriteCache(\"reminders.json\", new_data)  # Replace cache\nwriteConfig(\"settings.yaml\", config_dict)  # Write config\n```\n\n---\n---\n# cinLogging.py\n\nIt logs things. I'm tired. \n\nUses boxParams from cinPalette to print about things in pretty boxes. \n\nYou can also use `printInBoxP(text, boxParams)` and `printBoxBorderP(boxParams)` to print random arbitrary other things. Static boxParams objects (read: themes) are stored in cinPalettes \n\n`cinLogging.printInBoxP()` will auto-wrap text to the line width determined by the boxParams object arg.\n\nboxParams objects are structured as follows:\n\n```python\n@dataclass(slots=True, frozen=True)  \nclass BoxParams:  \n    box_color: str = highlightedColor  \n    box_indentation: int = 4  \n    indentation: int = 1  \n    width: int = 120 \n    text_color: str = defaultColor  \n    alt_first_border: bool = False\n```\n\n `cinPalettes` contains predefined boxParams objects for `LARGE_WINDOW_BORDER, LARGE_WINDOW, LARGE_WINDOW_HEADER, LOAD_STATUS,` and `ERROR_BOX` , as well as `HEADER_BOX` and `HEADER_BOX_BORDER`\n \n---\n---\n\n"
    },
    {
        "filename": "202510241259site deployment script.md",
        "title": "Shiny new Site Deployment Script",
        "subtitle": "woooo deploying this site doesn't suck so much anymore- ",
        "thumbnail": "https://i.imgur.com/R7ljDB7.png",
        "content": "# Shiny new Site Deployment Script\n\nI will NOT get into the details of how I was deploying these posts before (in this post at least?), but it's hosted on both github pages and neocities, with neocities pulling the post data from github pages to reduce the draw on neocities' servers as much as possible. When I push to the repository, the site updates.\n\n![screenshot of deploy.sh's source, with it running in a terminal window overlaid on top](https://i.imgur.com/R7ljDB7.png)\n\n### woooo deploying this site doesn't suck so much anymore- \n\nIt took like an hour of trying to remember how git worked, but now I don't have to think about that for another year, because publishing is just a double click away now. It's is not that major of a change, but I'm trying to make as much of this website as I can myself, so, little quality of life things like this are nice. I'm reducing my friction for writing little posts like these, somewhere that isn't twitteresc. It's nice-\n\n\nI'm just gonna hit save on this, click a the thing, and it totally won't error the moment I try to commit a real change.\n\n\n***\n<br>\nEDIT: Y'all I have hilarious news. My check for whether or not there were changes? Inverted. Detecting changes in the build script. Whoops.\n<br>\nEDIT 2: Code block for the deployment script, since why not:\n\n```bash\n#!/bin/bash\n\nCOMMIT_MSG=\"${1:-bump}\" # COMMIT_MSG = arg1 ? arg1 : \"bump\"\n\nRED='\\033[0;31m'\nGREEN='\\033[1;32m'\nCYAN='\\033[1;36m'\nGRAY='\\033[0;37m'\nC='\\033[0m'\n\necho\n\n# build\necho -e \"${CYAN}    ----    Starting build...    ----    \\n${C}\"\nif ! python3 build_js.py; then\n    echo -e \"${RED}\\n\\n    Build failed!\\n\\n${C}\"\n    exit 1\nfi\n\n# changes ? commit : no\necho\nif git diff-index --quiet HEAD --; then\n    echo -e \"${GRAY}    ----    No changes to commit.    ----    ${C}\"\nelse\n    echo -e \"${CYAN}    ----    Changes detected, committing...    ----    \\n${C}\"\n    git add . && \\\n    git commit -m \"$COMMIT_MSG\"\nfi\n\n# Push either way\necho -e \"\\n${CYAN}    ----    Pushing to GitHub...    ----    ${C}\\n\"\nif ! git push origin main; then\n    echo -e \"\\n\\n${RED}    ----    Failed to push to GitHub!    ----    ${C}\"\n    exit 1\nfi\n\necho -e \"${GREEN}\\n\\n    ----    Deployment completed successfully! Haven gice done    ----    \\n\\n${C}\"\n\n\nread -p \"[press any to close] \" -n1 -s\n```\n\nEDIT 3: Actually y'know what, have build_js.py too. These two scripts are how I'm deploying the site every time I make a minor edit like this:\n\n```python\nimport os\nimport re\nimport json\n\nPOSTS_DIR = './posts'\n\ndef parse_markdown(content):\n    # extract title (first level header `#`)\n    title_match = re.search(r'^# (.+)', content, re.MULTILINE)\n    title = title_match.group(1) if title_match else 'Untitled'\n\n    # extract subtitle (second level header `##`)\n    subtitle_match = re.search(r'^## (.+)', content, re.MULTILINE)\n    subtitle = subtitle_match.group(1) if subtitle_match else ''\n    \n    if subtitle == \"\":  # if contains no ##, try first ###\n        subtitle_match2 = re.search(r'^### (.+)', content, re.MULTILINE)\n        subtitle = subtitle_match2.group(1) if subtitle_match2 else ''\n\n    # extract thumbnail (first image URL `![](url)`)\n    thumbnail_match = re.search(r'!\\[.*?\\]\\((.*?)\\)', content)\n    thumbnail = thumbnail_match.group(1) if thumbnail_match else ''\n\n    return {\n        'title': title,\n        'subtitle': subtitle,\n        'thumbnail': thumbnail,\n        'content': content\n    }\n\ndef build_output_files(posts_dir):\n    posts_data = []\n\n    # foreach .md in dir\n    for filename in os.listdir(posts_dir): # can probably python list comprehension this one? but those aren't... readable.......\n        if filename.endswith('.md'):\n            with open(os.path.join(posts_dir, filename), 'r', encoding='utf-8') as f:\n                content = f.read()\n                post_data = parse_markdown(content)\n                posts_data.append({\n                    'filename': filename,\n                    'title': post_data['title'],\n                    'subtitle': post_data['subtitle'],\n                    'thumbnail': post_data['thumbnail'],\n                    'content': post_data['content']\n                })\n\n    # sort posts by most recent first (filename alphabetical, reversed)\n    posts_data.sort(key=lambda x: x['filename'], reverse=True)\n\n    # split into recent and whatever else for faster initial loading\n    recent_posts = posts_data[:2]\n    older_posts = posts_data[2:]\n\n    # generate JSON versions (for Neocities)\n    with open('recentPosts.json', 'w', encoding='utf-8') as f:\n        json.dump(recent_posts, f, indent=4, ensure_ascii=False)\n    \n    with open('olderPosts.json', 'w', encoding='utf-8') as f:\n        json.dump(older_posts, f, indent=4, ensure_ascii=False)\n\n    # generate JSONP versions (for GitHub Pages)\n    # todo: figure out how to get github pages to accept json-\n    with open('recentPosts.js', 'w', encoding='utf-8') as f:\n        f.write(f'handleRecentPosts({json.dumps(recent_posts, indent=4, ensure_ascii=False)});')\n    \n    with open('olderPosts.js', 'w', encoding='utf-8') as f:\n        f.write(f'handleOlderPosts({json.dumps(older_posts, indent=4, ensure_ascii=False)});')\n\n    print(\"Generated files successfully!\")\n    print(\"- JSON (for Neocities): recentPosts.json, olderPosts.json\")\n    print(\"- JSONP (for GitHub): recentPosts.js, olderPosts.js\")\n\nif __name__ == '__main__':\n    build_output_files(POSTS_DIR)\n```\n"
    }
]);